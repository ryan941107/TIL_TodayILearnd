# 깃허브 특강 210917

 



**git pull origin master** : pull 당기다, 깃 오리진의 마스터 브랜치에서 변경사항을 당겨오라는 명령어 

같은 레포지토리 저장하고 원격으로 끌어다 쓰기 가능, 먼저 당겨오지 않고  겹쳐서 사용하면 리젝트 거절 당함 

컨플릭트 상황 : 이미 등록된 줄이 있는 레포지토리에 당겨오지않고 써서 올리게되면 충돌나서 발생 

오류난 메시지 지우고 정리해서 에드 커밋 푸쉬해주면 된다. 



**git restore --staged {file}** 깃 에드해서 스테이징 에어리어에 임시 저장한 수정사항을 다시 내려줌 스테이지드에서 작동

**git restore** {file} 레포지토리와 워킹디렉토리 비교해서 워킹디렉토리에 있는 파일을 가장 최근에 했던 최신 커밋파일 상태로 초기화 시켜버림 

컨트롤 s 로 저장한 상태여도 이전커밋 상태와 비교해서 변경사항 지움 

**git reset --hard {c_id}**  c_id는 커밋 아이디 git log로 확인. 

- 이전 커밋으로 모든 상태가 돌아감. 

- 하드 옵션은 워킹디렉토리 스테이지드에어리어 레포지토리 전부 적용 

**git rebase**

**.gitignore** 원하지 않는 파일 제외하기 : .git 파일에 같이 위치해있어야 적용가능, touch .gitignore로 파일 만든후 안에 파일명 적으면 제외됨 (블랙리스트), 레포지토리 만든 직후에 바로 만듦 

- data.csv 	#특정파일
- secret/ 	#특정폴더
- *.png  	#특정 확장자
- !profile.png      # 모든 png는 빼고, profile.png는 넣고 

https://www.toptal.com/developers/gitignore  이 사이트 이용하면 자잘한거 제외시켜서 올려줌 

git init 레포지토리 만들고 우선적으로 README.md 와 .gitignore 만들어야함. 



---



**shared repository model** : 원격 레포지토리 동일한 저장소를 공유하여 활용하는 방식.

팀장 레포지토리 owner 

팀원 collaborator 팀원은 푸쉬 권한을 얻는다

팀장 : 깃 허브 -> 레포지토리 -> 세팅스 -> 매니지 어세스 -> 인바이트 어 콜라보레이션 

팀원 : 깃허브 -> 레퍼지토리 -> 주소 복사 -> vs코드에서 클론 주소 .git 





---



**브랜치 branch** 나뭇가지, 분기된 흐름이라는 뜻 : 특정 커밋을 가리키는 **포인터**

브랜치를 만들어야하나? 라는 고민이 들때 무조건 만드는 것을 추천! 



git init 하면 마스터 브랜치 생성. 

브랜치는 하나의 커밋을 가르키는 포인터 

code . 비쥬얼 코드 열림 깃 배쉬에서 치면 

**merge** 는 병합이란 뜻 브랜치가 여러개 나눠져있는데 머지쓰면 합쳐짐

각 브랜치에서 작업을 한 이후 이력을 합치기 위해서는 머지 명령어 사용

병합을 진행할때 만약 서로 다른 이력에서 동일한 파일을 수정한 경우 충돌이 발생 할 수 있다.

이 경우 반드시 직접 수정을 진행 해야한다. 

![명령어](%EA%B9%83%ED%97%88%EB%B8%8C%20%ED%8A%B9%EA%B0%952.assets/%EC%BA%A1%EC%B2%98.PNG)



fast forward merge 





**git log --graph** 브랜치 상황 보여줌 

**git log --graph --oneline**  커밋의 이력 한줄로 출력해서 더깔끔하게 보여줌

레포지토리 - > 풀 리퀘스트 -> 뉴 풀리퀘스트 

코드 -> 컴페어 체인지스 -> 마스터에서 테스트로 브랜치 변경   -> 크리에이트 풀리퀘스트 



깃 플로우 과정 

1. 마스터 브랜치는 반드시 배포 가능한 상태여야 한다 

2. 피쳐 브랜치는 각 기능의 의도를 알수 있도록 작성한다 

3. 커밋 메세지는 매우 중요하며 명확하게 작성한다

4. 풀 리퀘스트를 통해 협업을 진행한다.

5. 변경사항을 반영하고싶다면 마스터브랜치에 병합한다 

---



fork & pull model : 오픈소스  FORK는 복사를 의미 

두 모델의 가장 큰 차이점은 내가 해당 프로젝트 저장소에 직접적인 푸시 권한이 있는지 여부 

1. 깃헙 레포에서 나의 레포로 FORK 복사 해온다
2. 내 레포에서 클론 해온다 
3. 새 브런치를 만들어서 작업 
4. 내 레포로 다시 푸시 
5. 깃헙에 다시 PR을 보낸다





